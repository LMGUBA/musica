from flask import Flask, request, render_template, jsonify
import yt_dlp
import ssl
import json
from urllib.parse import quote

app = Flask(__name__)

# Deshabilitar verificación SSL globalmente
ssl._create_default_https_context = ssl._create_unverified_context

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        query = request.form.get("query", "").strip()
        if not query:
            return render_template("index.html", 
                                 error="Por favor ingresa un término de búsqueda")
        
        try:
            # Buscar canciones sin descargar
            search_results = search_songs(query)
            if search_results:
                return render_template("index.html", 
                                     search_results=search_results,
                                     query=query)
            else:
                return render_template("index.html", 
                                     error="No se encontraron resultados")
        except Exception as e:
            print(f"Error en búsqueda: {e}")
            return render_template("index.html", 
                                 error="Error al buscar canciones")

    return render_template("index.html")

@app.route("/get_audio_url", methods=["POST"])
def get_audio_url():
    """Obtener URL de audio directo para reproducción"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No se recibieron datos"}), 400
            
        video_url = data.get("video_url")
        if not video_url:
            return jsonify({"error": "URL no proporcionada"}), 400
        
        print(f"Obteniendo audio para: {video_url}")
        audio_url = get_direct_audio_url(video_url)
        
        if audio_url:
            print(f"URL de audio obtenida exitosamente")
            return jsonify({"success": True, "audio_url": audio_url})
        else:
            print("No se pudo obtener URL de audio")
            return jsonify({"error": "No se pudo obtener URL de audio válida"}), 500
            
    except Exception as e:
        print(f"Error al obtener audio: {e}")
        return jsonify({"error": f"Error del servidor: {str(e)}"}), 500

def generate_search_variations(search_term):
    """Generar variaciones de búsqueda para mejorar resultados"""
    variations = [search_term]
    
    # Agregar variaciones comunes
    variations.append(f"{search_term} música")
    variations.append(f"{search_term} canción")
    variations.append(f"{search_term} audio")
    variations.append(f"{search_term} oficial")
    
    # Variaciones específicas para artistas conocidos
    known_artists = {
        'kudai': ['kudai chile', 'kudai sin despertar', 'kudai ya nada sera', 'kudai banda chilena'],
        'mana': ['mana banda', 'mana mexicano'],
        'chayanne': ['chayanne puerto rico'],
        'shakira': ['shakira colombia'],
        'mago de oz': ['mago de oz españa']
    }
    
    search_lower = search_term.lower()
    for artist, artist_variations in known_artists.items():
        if artist in search_lower:
            variations.extend(artist_variations)
    
    return variations

def search_songs(search_term, max_results=25):
    """Buscar canciones en YouTube sin descargar con múltiples intentos"""
    search_variations = generate_search_variations(search_term)
    all_results = []
    
    print(f"Probando {len(search_variations)} variaciones de búsqueda para: {search_term}")
    
    for i, variation in enumerate(search_variations):
        if len(all_results) >= max_results:
            break
            
        search_query = f"ytsearch{max_results//len(search_variations) + 5}:{variation}"
        print(f"Búsqueda {i+1}: {variation}")
        
        ydl_opts = {
            'quiet': True,
            'noplaylist': True,
            'nocheckcertificate': True,
            'prefer_insecure': True,
            'extract_flat': False,
            'no_warnings': True,
            'http_headers': {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            },
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls']
                }
            }
        }
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(search_query, download=False)
                
                if 'entries' in info and info['entries']:
                    seen_ids = set()
                    for entry in info['entries']:
                        if entry and entry.get('title') and entry.get('webpage_url'):
                            video_id = entry.get('id', '')
                            
                            # Evitar duplicados
                            if video_id in seen_ids:
                                continue
                            seen_ids.add(video_id)
                            
                            # Filtrar videos muy largos (probablemente no sean canciones)
                            duration = entry.get('duration', 0)
                            if duration and duration > 600:  # 10 minutos
                                continue
                            
                            # Formatear duración
                            if duration:
                                duration_str = f"{duration//60}:{duration%60:02d}"
                            else:
                                duration_str = "Desconocido"
                            
                            # Obtener thumbnail seguro
                            thumbnail = ""
                            if entry.get('thumbnails'):
                                for thumb in entry['thumbnails']:
                                    if thumb.get('url'):
                                        thumbnail = thumb['url']
                                        break
                            
                            result_data = {
                                'title': clean_string(entry.get('title', 'Título desconocido')),
                                'uploader': clean_string(entry.get('uploader', 'Canal desconocido')),
                                'duration': duration_str,
                                'view_count': format_views(entry.get('view_count', 0)),
                                'url': entry.get('webpage_url', ''),
                                'thumbnail': thumbnail,
                                'id': entry.get('id', ''),
                                'upload_date': entry.get('upload_date', '')
                            }
                            all_results.append(result_data)
                            
                            if len(all_results) >= max_results:
                                break
                
        except Exception as e:
            print(f"Error en variación '{variation}': {str(e)}")
            continue
    
    # Eliminar duplicados finales y ordenar por relevancia
    unique_results = []
    seen_urls = set()
    
    for result in all_results:
        if result['url'] not in seen_urls:
            seen_urls.add(result['url'])
            unique_results.append(result)
    
    print(f"Se encontraron {len(unique_results)} resultados únicos")
    return unique_results[:max_results]

def clean_string(text):
    """Limpiar strings para evitar problemas con caracteres especiales"""
    if not text:
        return ""
    # Reemplazar caracteres problemáticos
    text = str(text).replace("'", "&#39;").replace('"', "&quot;")
    return text

def format_views(views):
    """Formatear número de visualizaciones"""
    if not views or views == 0:
        return "0"
    
    try:
        views = int(views)
        if views >= 1000000:
            return f"{views/1000000:.1f}M"
        elif views >= 1000:
            return f"{views/1000:.1f}K"
        else:
            return str(views)
    except (ValueError, TypeError):
        return "0"

def get_direct_audio_url(video_url):
    """Obtener URL directo del audio sin descargar"""
    ydl_opts = {
        'format': 'bestaudio[ext=webm]/bestaudio[ext=m4a]/bestaudio/best[height<=480]',
        'quiet': True,
        'noplaylist': True,
        'nocheckcertificate': True,
        'prefer_insecure': True,
        'no_warnings': True,
        'http_headers': {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        },
        'extractor_args': {
            'youtube': {
                'skip': ['dash', 'hls']
            }
        }
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            print(f"Extrayendo info de: {video_url}")
            info = ydl.extract_info(video_url, download=False)
            
            if not info:
                print("No se pudo obtener información del video")
                return None
            
            # Buscar el mejor formato de audio compatible con navegadores
            formats = info.get('formats', [])
            if not formats:
                print("No se encontraron formatos disponibles")
                return None
            
            # Priorizar formatos compatibles con navegadores
            preferred_formats = ['webm', 'm4a', 'mp4']
            
            for preferred in preferred_formats:
                for fmt in formats:
                    if (fmt.get('acodec') and fmt.get('acodec') != 'none' and 
                        fmt.get('ext') == preferred and
                        fmt.get('url') and
                        not fmt.get('url').startswith('https://manifest')):
                        
                        audio_url = fmt.get('url')
                        print(f"Formato seleccionado: {preferred}")
                        return audio_url
            
            # Fallback: buscar cualquier formato de audio válido
            for fmt in formats:
                if (fmt.get('acodec') and fmt.get('acodec') != 'none' and 
                    fmt.get('url') and
                    not fmt.get('url').startswith('https://manifest') and
                    fmt.get('filesize', 0) != 0):
                    
                    audio_url = fmt.get('url')
                    print(f"Formato fallback: {fmt.get('ext', 'unknown')}")
                    return audio_url
            
            print("No se encontró formato de audio compatible")
            return None
            
    except Exception as e:
        print(f"Error obteniendo URL de audio: {e}")
        import traceback
        traceback.print_exc()
        return None

# Manejo de errores global
@app.errorhandler(404)
def not_found_error(error):
    return render_template('index.html', error="Página no encontrada"), 404

@app.errorhandler(500)
def internal_error(error):
    return render_template('index.html', error="Error interno del servidor"), 500

if __name__ == "__main__":
    print("Iniciando servidor Flask...")
    print("Accede a: http://localhost:8080")
    app.run(debug=True, host='0.0.0.0', port=8080, threaded=True)